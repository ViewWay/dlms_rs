# HCS (Header Check Sequence) 实现设计方案

## 问题分析

根据 `dlms-docs/dlms/hdlc帧格式.txt` 文档，HDLC帧的正确结构应该是：

```
标志(0x7E) | 帧格式(2) | 目的地址 | 源地址 | 控制(1) | HCS(2) | 信息 | FCS(2) | 标志(0x7E)
```

**当前实现问题**:
- ❌ 缺少HCS字段（应该在控制域之后，信息域之前）
- ❌ 当前FCS计算包含了头部，但没有单独的HCS校验
- ❌ 信息域有独立的FCS，但这不是标准格式

## 设计方案

### 1. HCS计算范围

根据文档（hdlc帧格式.txt:128-129）：
```
HCS计算除了开始标志和HCS本身外的头的字节数
```

**HCS计算范围**:
- 帧格式 (2字节)
- 目的地址 (1-4字节)
- 源地址 (1-4字节)
- 控制域 (1字节)

**总计**: 5-11字节（取决于地址长度）

### 2. FCS计算范围

根据文档（hdlc帧格式.txt:133-134）：
```
FCS计算除开始标志和FCS本身外的完整帧长度
```

**FCS计算范围**:
- 帧格式 (2字节)
- 目的地址 (1-4字节)
- 源地址 (1-4字节)
- 控制域 (1字节)
- **HCS (2字节)** ← 新增
- 信息域 (可变长度)

### 3. 帧长度计算

根据文档（hdlc帧格式.txt:106）：
```
长度子域的值是除两个 7E 标志位之外的8位位组数
```

**长度字段应该包括**:
- 帧格式 (2字节) - 但长度字段本身在帧格式中，所以不重复计算
- 目的地址
- 源地址
- 控制域
- **HCS (2字节)** ← 新增
- 信息域（如果有）
- FCS (2字节)

**注意**: 长度字段本身不包含在长度计算中（这是标准的做法）

## 实现方案

### 编码流程 (encode)

1. 编码帧格式（初始值，长度待计算）
2. 编码目的地址
3. 编码源地址
4. 编码控制域
5. **计算并编码HCS** ← 新增
6. 编码信息域（如果有）
7. 计算并编码FCS（包括HCS）
8. 计算并更新帧格式中的长度字段

### 解码流程 (decode)

1. 读取并验证帧格式
2. 读取目的地址
3. 读取源地址
4. 读取控制域
5. **读取并验证HCS** ← 新增
6. 读取信息域（如果有）
7. 读取并验证FCS

## 实现细节

### HCS计算

使用与FCS相同的CRC算法（X**0 + X**5 + X**12 + X**16），但只计算头部字段。

### 错误处理

- HCS验证失败：返回 `DlmsError::FrameInvalid`
- FCS验证失败：返回 `DlmsError::FrameInvalid`
- 帧长度不足：返回 `DlmsError::FrameInvalid`

## 优化考虑

1. **性能**: HCS和FCS使用相同的FcsCalc，可以复用
2. **内存**: HCS是固定2字节，不需要额外分配
3. **兼容性**: 需要确保与现有代码的兼容性

## 风险评估

- **高风险**: 修改帧结构可能影响现有测试和兼容性
- **缓解措施**: 
  - 添加详细的单元测试
  - 确保向后兼容（如果有旧格式的帧）
  - 添加版本检查或配置选项

## 测试计划

1. 单元测试：HCS计算和验证
2. 集成测试：完整帧编码/解码
3. 兼容性测试：与标准DLMS设备通信
