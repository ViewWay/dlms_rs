# RR帧自动发送修复总结

## 修复完成时间
2025-01-XX

## 问题描述
根据 `dlms-docs/dlms/长数据帧处理.txt` 文档：
- 在数据帧被分割传输时，帧类型与帧长字段中的S位，将被置1
- Client通过发送RR数据帧来请求被分割的数据帧的其余部分

原实现中没有自动检测分段帧和发送RR帧的功能。

## 修复内容

### 1. 新增分段帧重组器

**新增结构**: `SegmentedFrameReassembler`
- 管理分段帧的重组状态
- 跟踪期望的下一帧序列号
- 处理超时和错误

### 2. 修改的文件
- `dlms-session/src/hdlc/connection.rs`
- `dlms-session/src/hdlc/frame.rs`

### 3. 具体修改

#### 新增SegmentedFrameReassembler结构
- ✅ 状态管理：当前消息数据、期望序列号、超时跟踪
- ✅ `start()`方法：开始新的分段消息重组
- ✅ `add_segment()`方法：添加分段并检查是否完成
- ✅ `is_timeout()`方法：检查超时
- ✅ `reset()`方法：重置状态

#### 修改HdlcConnection结构
- ✅ 添加`reassembler`字段
- ✅ 在`new()`中初始化重组器

#### 新增receive_segmented()方法
- ✅ 自动检测分段帧（S位=1）
- ✅ 自动发送RR帧请求下一段
- ✅ 自动重组分段数据
- ✅ 返回完整的重组消息

#### 新增send_rr_frame()方法
- ✅ 发送带N(R)的RR帧
- ✅ 正确设置控制字节

#### 修改HdlcFrame
- ✅ 新增`new_receive_ready()`方法：创建带N(R)的RR帧

## 设计决策

### 为什么需要分段帧重组？
1. **协议要求**: 根据文档，Client必须通过发送RR帧请求下一段
2. **透明处理**: 用户不需要手动处理分段逻辑
3. **完整性**: 确保分段消息完整接收

### 分段帧处理流程
1. 检测到分段帧（S位=1）
2. 提取数据并开始/继续重组
3. 发送RR帧，N(R) = 期望的下一序列号
4. 等待下一帧
5. 重复直到收到S位=0的帧
6. 返回完整消息

### 序列号管理
- **N(S)**: 发送序列号（在控制字节bits 1-3）
- **N(R)**: 接收序列号（在控制字节bits 5-7）
- **RR帧N(R)**: 表示期望接收的下一个序列号

### 错误处理策略
- **超时**: 如果5秒内未收到下一段，返回错误
- **序列号错误**: 如果收到意外的序列号，返回错误
- **缓冲区溢出**: 如果消息超过64KB，返回错误

## 优化考虑

1. **超时处理**: 默认5秒，可配置
2. **缓冲区限制**: 最大64KB，防止内存耗尽
3. **状态管理**: 清晰的状态跟踪和清理
4. **错误恢复**: 超时或错误后自动重置状态

## 兼容性影响

### 非破坏性变更
- ✅ `receive_frames()`保持不变：返回原始帧列表
- ✅ 新增`receive_segmented()`：可选使用自动重组
- ✅ 向后兼容：现有代码不受影响

### 建议
- 对于需要处理分段帧的场景，使用`receive_segmented()`
- 对于需要手动控制的场景，继续使用`receive_frames()`

## 测试建议

### 单元测试
1. 分段帧检测
2. RR帧发送（N(R)值正确）
3. 分段帧重组（多段消息）
4. 超时处理
5. 序列号错误处理
6. 缓冲区溢出处理

### 集成测试
1. 完整的分段消息接收流程
2. 多段消息（2段、3段、多段）
3. 超时情况
4. 错误恢复

### 兼容性测试
1. 与标准DLMS设备通信
2. 不同分段大小测试
3. 网络中断恢复测试

## 已知限制

1. **单消息重组**: 当前实现只支持一个分段消息同时重组
   - 未来可以扩展支持多个并发分段消息

2. **固定超时**: 超时时间固定为5秒
   - 未来可以添加配置选项

3. **固定缓冲区**: 最大缓冲区64KB
   - 未来可以添加配置选项

## 下一步
根据检查报告，所有高优先级和中优先级的修复已完成：
- ✅ HCS实现
- ✅ SNRM/UA握手
- ✅ UA帧参数解析
- ✅ DISC/DM/UA断开流程
- ✅ RR帧自动发送

剩余的低优先级任务：
- LLC字段处理明确化
- 帧长度计算规则确认
