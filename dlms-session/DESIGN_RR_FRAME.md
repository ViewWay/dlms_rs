# RR帧自动发送设计方案

## 问题分析

根据 `dlms-docs/dlms/长数据帧处理.txt` 文档：

### 分段帧处理
- 在数据帧被分割传输时，帧类型与帧长字段中的S位，将被置1
- Client通过发送RR数据帧来请求被分割的数据帧的其余部分

### 需求
1. 检测分段帧（S位=1）
2. 自动发送RR帧请求下一段
3. 重组分段帧数据

## 设计方案

### 1. 分段帧状态管理

需要跟踪：
- 当前正在接收的分段消息
- 已接收的帧数据
- 期望的下一帧序列号
- 超时处理

### 2. 实现方案

#### 方案A: 在receive_frames()中自动处理
- 优点：对用户透明
- 缺点：可能阻塞，需要状态管理

#### 方案B: 提供新的receive_segmented()方法
- 优点：用户可以选择是否使用自动重组
- 缺点：需要用户显式调用

#### 方案C: 在连接层维护分段状态
- 优点：状态集中管理
- 缺点：需要额外的状态结构

### 3. 推荐方案：方案C + 辅助方法

在`HdlcConnection`中添加：
1. 分段帧重组器（`SegmentedFrameReassembler`）
2. `receive_segmented()`方法：自动处理分段帧
3. `receive_frames()`保持不变：返回原始帧列表

### 4. 分段帧重组器设计

```rust
struct SegmentedFrameReassembler {
    current_message: Option<Vec<u8>>,  // 当前正在重组的数据
    expected_sequence: u8,              // 期望的下一帧序列号
    timeout: Duration,                   // 超时时间
    last_receive_time: Option<Instant>,  // 最后接收时间
}
```

### 5. RR帧发送逻辑

1. 检测到分段帧（S位=1）
2. 提取接收序列号（N(R)）
3. 发送RR帧，N(R) = 当前接收序列号 + 1
4. 等待下一帧
5. 重复直到收到S位=0的帧

### 6. 错误处理

- **超时**: 如果在一定时间内未收到下一帧，返回错误
- **序列号错误**: 如果收到意外的序列号，返回错误
- **连接关闭**: 如果连接关闭，清理状态

### 7. 优化考虑

1. **超时时间**: 可配置，默认5秒
2. **缓冲区管理**: 限制最大重组数据大小
3. **并发处理**: 考虑多个分段消息同时进行的情况

## 实现步骤

1. 定义`SegmentedFrameReassembler`结构
2. 在`HdlcConnection`中添加重组器字段
3. 实现`receive_segmented()`方法
4. 实现RR帧自动发送逻辑
5. 实现分段帧重组逻辑
6. 添加错误处理和超时处理

## 测试计划

1. **单元测试**:
   - 分段帧检测
   - RR帧发送
   - 分段帧重组

2. **集成测试**:
   - 完整的分段消息接收
   - 超时处理
   - 错误情况处理

## 风险评估

- **中等风险**: 状态管理复杂，可能引入bug
- **缓解措施**: 
  - 详细的状态机设计
  - 完善的错误处理
  - 充分的测试
